<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7 Chapter 11</title>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/small.css">
    <link rel="stylesheet" href="../css/medium.css">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#395b50">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#395b50">
    <style></style>
</head>

<body>
    <header>
        <H1>
            WDD 330 Portfolio
        </H1>
    </header>
    <main>
        <h2 class="mainTitle">Week 7 Notes</h2>
        <H3>Chapter 11</H3>
        <p>Some examples are in the console and code comments. </p>
        <ul>
            <li>
                The call method of functions can be used to set the value of this inside a function to an object that is
                provided in the first argument.
            </li>
            <li>
                If a function doesn’t refer to an object as this in its body, it can be called using the call() method,
                but you need to provide null as the first argument.
            </li>
            <li>
                The apply() method works in the same way, but the arguments must be provided as an array.
            </li>
            <li>
                You can add your own properties to functions just like any object in JavaScript.
            </li>
            <li>
                Memoization is a term for result caching. The cache object stores the results of the function.
            </li>
            <li>
                Immediately Invoked Function Expression (IIFE) is invoikes as soon as it is defined.
            </li>
            <li>
                Once a variable has been declared, it can’t be removed from its scope.
            </li>
            <li>
                Placing code using temporary variables inside and IIFE will ensure it is only available for the IIFE.
            </li>
            <li>
                Initialization Code that won’t be needed again can be set up as an IIFE. This code is only run once.
            </li>
            <li>
                The recommended way to use strict mode is to place all your code inside an IIFE, so that it doesn’t
                encounter errors if other people’s code is not strict.
            </li>
            <li>
                An IIFE can enclose a block of code inside its own private scope so it doesn’t interfere with other
                parts of the program.
            </li>
            <li>
                A function can call itself, define itself, and redefine itself. This is done by assigning an anonymous
                function to a variable that has the same name as the function.
            </li>
            <li>
                Init-Time Branching is when a function rewrites itself at the time of initialization so that it avoids
                check for browser features every time it is invoked.
            </li>
            <li>
                Recursive functions invoke themselves until a certain condition is met.
            </li>
            <li>
                Callbacks are functions passed to other functions and then invoked inside the function they are passed
                to.
            </li>
            <li>
                Callbacks can facilitate event-driven asynchronous programming, or code that can run out of order.
            </li>
            <li>
                Callbacks can lead to confusing spaghetti code.
            </li>
            <li>
                A promise represents the future result of an asynchronous operation. Promises do the same thing that
                callbacks can, but it simplifies the process.
            </li>
            <li>
                A promise pending when it is made, and then is settled as Resolved or Rejected.
            </li>
            <li>
                Promises are created using a constructor function.
            </li>
            <li>
                When a promise has been settled, the then() method can be used to deal with the outcome.
            </li>
            <li>
                The .catch() method can be used to specify what to do if the operation fails.
            </li>
            <li>
                Promises can be chained together with multiple asynchronous tasks that need to be carried out one after
                the other.
            </li>
            <li>
                Callbacks can be used to build more generalized functions, rather than a lot of specific functions.
            </li>
            <li>
                While functions can accept other functions as an argument, they can also return a function.
            </li>
            <li>
                Closures are a bit confusing, but they deal with scope of functions and being able to use variables from
                one scope in a different scope.
            </li>
            <li>
                A closure is formed when a function returns another function that then maintains access to any variables
                created in the original function’s scope.
            </li>
            <li>
                Closures allow for things like counter functions to work.
            </li>
            <li>
                Generators are special functions that are used to produce iterators that maintain the state of a value.
            </li>
            <li>
                Generator functions are defined with ‘*’ after the function declaration.
            </li>
            <li>
                Calling a generator function doesn’t run the code, but it returns a generator object used to create an
                iterator that implements a next() method.
            </li>
            <li>
                Generator functions use the special yield keyword that is used to return a value. Yield is like return
                except that the state of the value returned is remembered.
            </li>
            <li>
                Functional programming is a programming paradigm, and focuses on use of pure functions.
            </li>
            <li>
                Pure functions return values that only depend on the values provided as arguments.
            </li>
            <li>
                Pure functions have no side-effects.
            </li>
            <li>
                Pure functions have referential transparency.
            </li>
            <li>
                Higher-order functions accept another function as an argument and/or return another function.
            </li>
            <li>
                Currying is a process that involves partial application of functions.
            </li>
            <li>
                Curried functions return another function that retains the arguments provided and expects the remaining
                arguments that were omitted when the original was called.
            </li>
        </ul>
    </main>
    <Footer>
        <a href="index.html">Return to Week 7</a>
    </Footer>
    <script>
        function square(x) {
            square.cache = square.cache || {};
            if (!square.cache[x]) {
                square.cache[x] = x * x;
            }
            return square.cache[x]
        }
        square.description = 'Squares a number that is provided as an argument'

        console.log(square.length)
        //call and apply
        function sayHello(greeting = 'Hello') {
            return `${ greeting }, my name is ${ this.name }`;
        }

        const clark = {
            name: 'Clark'
        };
        const bruce = {
            name: 'Bruce'
        };
        console.log(sayHello.call(clark));
        console.log(sayHello.call(bruce));


        // IIFE

        (function () {
            const temp = 'World';
            console.log(`Hello ${temp}`);
        })();

        let [a, b] = [1, 2];
        [a, b] = [b, a];

        (function () {
            const name = 'Peter Parker'; // This might be obtained from a cookie in reality
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const date = new Date(),
                today = days[date.getDay()];
            console.log(`Welcome back ${name}. Today is ${today}`);
        })();

        (function () {
            // block A
            const name = 'Block A';
            console.log(`Hello from ${name}`);
        }());
        (function () {
            // block B
            const name = 'Block B';
            console.log(`Hello from ${name}`);
        }());

        function party() {
            console.log('Wow this is amazing!');
            party = function () {
                console.log('Been there, got the T-Shirt');
            }
        }
        const beachParty = party;

        function ride() {
            if (window.unicorn) {
                ride = function () {
                    // some code that uses the brand new and sparkly unicorn methods
                    return 'Riding on a unicorn is the best!';
                }
            } else {
                ride = function () {
                    // some code that uses the older pony methods
                    return 'Riding on a pony is still pretty good';
                }
            }
            return ride();
        }
        console.log(ride());

        //Recursive

        function factorial(n) {
            if (n === 0) {
                return 1;
            } else {
                return n * factorial(n - 1);
            }
        }

        function collatz(n, sequence = [n]) {
            if (n === 1) {
                return `Sequence took ${sequence.length} steps. It was ${sequence}`;
            }
            if (n % 2 === 0) {
                n = n / 2;
            } else {
                n = 3 * n + 1;
            }
            return collatz(n, [...sequence, n]);
        }

        function wait(message, callback, seconds) {
            setTimeout(callback, seconds * 1000);
            console.log(message);
        }

        function selfDestruct() {
            console.log('BOOOOM!');
        }
        wait('This tape will self-destruct in five seconds ... ', selfDestruct, 5);
        console.log('Hmmm, should I accept this mission or not ... ?');

        // const promise = new Promise((resolve, reject) => {
        //     // initialization code goes here
        //     if (success) {
        //         resolve(value);
        //     } else {
        //         reject(error);
        //     }
        // });

        const dice = {
            sides: 6,
            roll() {
                return Math.floor(this.sides * Math.random()) + 1;
            }
        }
        console.log('Before the roll');
        const roll = new Promise((resolve, reject) => {
            const n = dice.roll();
            if (n > 1) {
                setTimeout(() => {
                    resolve(n)
                }, n * 200);
            } else {
                setTimeout(() => reject(n), n * 200);
            }
        });
        roll.then(result => console.log(`I rolled a ${result}`))
            .catch(result => console.log(`Drat! ... I rolled a ${result}`));
        console.log('After the roll');

        //Async functions
        async function loadGame(userName) {
            try {
                const user = await login(userName);
                const info = await getPlayerInfo(user.id);
                // load the game using the returned info
            } catch (error) {
                throw error;
            }
        }

        function returnHello() {
            console.log('returnHello() called');
            return function () {
                console.log('Hello World!');
            }
        }
        const hello = returnHello();

        //closure
        function counter(start) {
            let i = start;
            return function () {
                return i++;
            }
        }
        const count = counter(1);


        function* fibonacci(a, b) {
            let [prev, current] = [a, b];
            while (true) {
                [prev, current] = [current, prev + current];
                yield current;
            }
        }
        const sequence = fibonacci(1, 1);


        //pure function
        const number = 42;

        function pureAdd(x, y) {
            return x + y;
        }
        result = pureAdd(number, 10);
        console.log(result);


    </script>
</body>

</html>